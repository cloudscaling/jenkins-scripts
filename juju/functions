#!/bin/bash

INSTANCE_TYPE="instance-type=t2.medium"

function wait_absence_status_for_services() {
  sleep 10
  check_str=$1
  local max_iter=${2:-30}
  # waiting for services
  local iter=0
  while juju status | grep -P $check_str &>/dev/null
  do
    echo "Waiting for all service to be active - $iter/$max_iter"
    if ((iter >= max_iter)); then
      echo "ERROR: Services didn't up."
      juju status
      return 1
    fi
    if juju status | grep "current" | grep error ; then
      echo "ERROR: Some services went to error state"
      juju status
      return 1
    fi
    sleep 30
    ((++iter))
  done
}

function wait_for_removed() {
  sleep 10
  check_str=$1
  local max_iter=${2:-5}
  # waiting for services
  local iter=0
  while juju status | grep "$check_str/" &>/dev/null
  do
    echo "Waiting for all units to be removed - $iter/$max_iter"
    if ((iter >= max_iter)); then
      echo "ERROR: Units didn't removed."
      juju status
      return 1
    fi
    if juju status | grep "current" | grep error ; then
      echo "ERROR: Some services went to error state"
      juju status
      return 1
    fi
    sleep 30
    ((++iter))
  done
}

function get_mdm_machines() {
  juju status scaleio-mdm --format json | jq .machines | jq keys | tail -n +2 | head -n -1 | sed -e "s/[\",]//g"
}

function get_master_mdm() {
  get_mdms=${1:-get_mdm_machines}
  master_mdm=''
  for mch in `$get_mdms` ; do
    if juju ssh $mch sudo scli --query_cluster --approve_certificate 2>/dev/null 1>/dev/null ; then
      echo "$mch"
      return
    fi
  done
  return 1
}

function get_cluster_mode() {
  juju get scaleio-mdm | grep -A 5 cluster-mode | grep "value:" | head -1 | awk '{print $2}'
}

function wait_for_machines() {
  # wait for machines
  sleep 30
  for machine in $@ ; do
    echo "Waiting for machine: $machine"
    local fail=0
    while ! output=`juju ssh $machine "sudo apt-get install -fy joe" 2>/dev/null` ; do
      if ((fail >= 12)); then
        echo "ERROR: Machine $machine did not up."
        echo $output
        exit 1
      fi
      sleep 10
      ((++fail))
    done
    juju ssh $machine uname -a 2>/dev/null
  done
}

function wait_status() {
  wait_absence_status_for_services "executing|blocked|waiting|allocating"

  # check for errors
  if juju status | grep "current" | grep error >/dev/null ; then
    echo "ERROR: Some services went to error state"
    juju ssh 0 sudo grep Error /var/log/juju/all-machines.log 2>/dev/null
    echo "---------------------------------------------------------------------------"
    juju status
    echo "---------------------------------------------------------------------------"
    return 2
  fi
}

# Waits amazon volume state
function wait_state() {
  volume_id=$1
  state=$2
  local fail=0
  while ! aws ec2 describe-volumes --volume-id $volume_id | grep "State" | grep -q $state ; do
    if ((fail >= 12)); then
      echo "ERROR: Volume $volume_id isn't $state"
      echo aws ec2 describe-volumes --volume-id $volume_id
      exit 1
    fi
    sleep 10
    ((++fail))
  done
}

# Creates volume on amazon and attaches it to the instance
# Path must be in range xvdf - xvdp for amazon
function create_attach_volume() {
    instance=$1
    volume_size=$2
    path=$3
    zone=`aws ec2 describe-instance-status --instance-ids $instance | grep "AvailabilityZone" | sed 's/[,\"]//g' | awk '{print$2}'`
    region=`echo $zone | sed 's/.$//'`
    if [[ -z "$instance" && -z "$volume_size" && -z "$path" ]] ; then
      echo "ERROR: script takes instance_id, volume_size and path as parameters"
      exit 1
    fi

    echo "Creating and attaching volume to instance $instance"
    volume=$(aws ec2 create-volume --size 100 --region $region --availability-zone $zone --volume-type gp2 | grep 'VolumeId' | sed 's/[,\"]//g' | awk '{print$2}')
    wait_state $volume "available"

    aws ec2 attach-volume --volume-id $volume --instance-id $instance --device $path 1>/dev/null
    wait_state $volume "attached"

    aws ec2 modify-instance-attribute --instance-id $instance --block-device-mappings "[{\"DeviceName\": \"$path\",\"Ebs\":{\"DeleteOnTermination\":true}}]" 1>/dev/null
}
